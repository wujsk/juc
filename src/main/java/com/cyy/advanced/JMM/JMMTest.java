package com.cyy.advanced.JMM;

/**
 * @program: juc
 * @description:
 * @author: cyy
 * @create: 2024-12-12 16:38
 * 由于cpu和物理主内存的速度不一致
 * cpu的运行并不是直接操作内存，而是先把内存当中的数据放到缓存当中，而物理主内存的读和写操作有时候就会造成不一致的问题
 *
 * JVM规范中试图定义一种Java内存模型（java memory model） 来屏蔽各种硬件和操作系统的内存访问差异，
 * 以实现让Java程序在各种平台都能达到一致的内存访问效果。
 *
 * JMM(Java内存模型Java Memory Model，简称JMM)本身是一种抽象的概念并不真实存在它仅仅描述的是一组约定或规范，通过这组
 *  规范定义了程序中(尤其是多线程)各个变量的读写访问方式并决定一个线程对共享变量的写入何时以及如何变成对另一个线程可见，
 *  关键技术点都是围绕多线程的原子性、可见性和有序性展开的。
 * 原则:
 *  JMM的关键技术点都是围绕多线程的原子性、可见性和有序性展开的
 * 能干嘛?
 *  1通过JMM来实现线程和主内存之间的抽象关系。
 *  2屏蔽各个硬件平台和操作系统的内存访问差异以实现让Java程序在各种平台下都能达到一致的内存访问效果。
 *
 *  JMM规范下，三大特性：
 *   1.原子性（）
 *   2.有序性（）
 *   3.可见性（是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即直到该变更，JMM规定了所有变量都存储在主内存当中）
 *  JMM定义了线程与主内存之间的抽象关系
 *   1.线程之间的共享变量存储在主内存当中（从硬件角度来说就是内存条）。
 *   2.每个线程都有一个私有的本地工作内存，本地工作内存中存储了该线程所引用的主内存变量的数据副本（从硬件角度来说就是CPU的缓存，比如说寄存器
 *   、L1、L2、L3缓存）。
 *   3.线程对共享变量所有操作都必须现在线程自己的工作内存中进行后写回主内存，不能直接从主内存中读写（不能越级）。
 *   4.不同线程之间也无法访问其他线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行（同级不能相互访问）。
 *  JMM规范中，多线程先行发生的原则之happens-before
 *    总原则：
 *      1.如果一个操作happens-before另一个操作，那么第一个操作执行结果将对第二个操作可见，而且第一个操作必须先行发生于第二个操作。
 *      2.两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行，如果重排序之后之后的执行结果
 *        与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。（例：1 + 2 + 3 = 3 + 2 + 1）
 *    8条原则：
 *      1.次序规则：一个线程内，按照代码顺序，写在前面的操作先行发生在写在后面的操作。
 *      2.锁定规则：一个unlock操作先行发生于后面（这里的后面是指时间的先后）对同一个锁的lock操作。
 *      3.volatile变量规则：对一个volatile变量的写操作先行发生在后面对这个变量的读操作，前面的写是对后面的读是可见的，这里的后面也是时间上的先后。
 *      4.传递规则：如果操作A先行发生于操作B，操作B先行发生于操作C，那么操作A先行发生于操作C。
 *      5.线程启动规则：Thread对象的start（）方法先行发生于此线程的每一个动作。
 *      6.线程中断规则：对线程interrupt（）方法的调用先行发生于被中断线程的代码检测到中断事件的发生，
 *                    也就是说你要先调用interrupt（）方法设置中断标志位，我才能检测到中断发送。
 *      7.线程终止规则：线程中的所有动作都先行发生于一个检测到线程终止动作。
 *      8.对象终结规则：一个对象的初始化完成先行发生于它的finalize（）（垃圾回收操作）方法的开始。
 *                    对象死之前，必须要先出生。
 *  JMM已经给Java语言添加了volatile、synchronized、final、线程启动、join、wait、notify等关键字，来保证这些关键字语义下，
 **/
public class JMMTest {
    public static void main(String[] args) {
        /**
         * 在JMM中，如果一个操作执行的结果需要对另一个操作可见性或者代码重排序，
         * 那么这两个操作之间必须存在happens-before（先行发生）原则。
         * 逻辑上的先后关系
         */
        int i = 0;
        i++;
    }
}
